#![allow(unreachable_pub)]

use std::str::FromStr;

xflags::xflags! {
    src "./src/cli.rs"

    cmd cli {
         cmd docs {}
         cmd example {
            required name: String
            required target: TargetType

            optional --release
            optional --no-assets
            optional --gzip
        }

        cmd examples {
            required target: TargetType

            optional --release
            optional --gzip
        }
    }
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Cli {
    pub subcommand: CliCmd,
}

#[derive(Debug)]
pub enum CliCmd {
    Docs(Docs),
    Example(Example),
    Examples(Examples),
}

#[derive(Debug)]
pub struct Docs;

#[derive(Debug)]
pub struct Example {
    pub name: String,
    pub target: TargetType,

    pub release: bool,
    pub no_assets: bool,
    pub gzip: bool,
}

#[derive(Debug)]
pub struct Examples {
    pub target: TargetType,

    pub release: bool,
    pub gzip: bool,
}

impl Cli {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end

#[derive(Copy, Clone, Debug, Default)]
pub enum TargetType {
    #[default]
    Msvc,
    Web,
}

impl FromStr for TargetType {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "msvc" => Ok(Self::Msvc),
            "web" => Ok(Self::Web),
            _ => Err("Invalid option".to_owned()),
        }
    }
}
